[{"title":"搭建k8s集群","url":"/2025/04/19/k8s_build/","content":"搭建k8s集群 注意，1-5步需要在master和node结点上都运行 ubuntu配置k8s集群 1.环境配置1.1 配置hosts 添加你结点的地址信息，比如我的是 1.2 关闭swap分区[一定要做] 1.3 禁用selinux（一般是默认禁用的） 1.4 允许 iptables 检查桥接流量 1.5 加载ip_vs内核模块 2.安装docker 【温馨提示】dockerd 实际真实调用的还是 containerd 的 api 接口，containerd 是 dockerd 和 runC 之间的一个中间交流组件。所以启动 docker 服务的时候，也会启动 containerd 服务的。 kubernets 自ｖ 1.24.0 后，就不再使用 docker.shim，替换采用 containerd 作为容器运行时端点。因此需要安装 containerd（在 docker 的基础下安装），上面安装 docker 的时候就自动安装了 containerd 了。这里的 docker 只是作为客户端而已。容器引擎还是 containerd。 3.配置 安装cri-dockerd【可忽略，如果要使用docker作为CRI，就需要，但是我还是推荐使用docker底层使用的containerd，也是k8s推荐的】Docker Engine 没有实现 CRI， 而这是容器运行时在 Kubernetes 中工作所需要的。 为此，必须安装一个额外的服务 cri-dockerd。 cri-dockerd 是一个基于传统的内置 Docker 引擎支持的项目， 它在 1.24 版本从 kubelet 中移除。 4.安装kubeadm kubelet kubectl 5.拉取所需镜像 6.使用kubeadm创建集群6.1 执行kubeadm init【master结点】 成功的话就是下面的输出 6.2 配置环境变量 查看结点 6.3 node结点加入 执行后，就可以在master结点使用kubectl get nodes发现结点已经加入了 6.4 安装Pod网络插件接下来就是安装Pod网络插件（CNI：Container Network Interface） 这里我们选用flannel作为CNI 首先我们得先下载kube-flannel.yml，可以去它官网flannel下载 这里我也贴出来文件内容，你也可以直接复制 我们可以从文件里看到，这个需要下两个镜像ghcr.io/flannel-io/flannel:v0.26.6和ghcr.io/flannel-io/flannel-cni-plugin:v1.6.2-flannel1 由于网络问题，这个我们可以考虑从自己的电脑上拉取镜像然后传到服务器上 可能用到的命令 这里还要强调下文件里的一个地方 这个Network应该和前面的kubeadm init指定的pod-network-cidr保持一致 前提工作做好后，就可以执行 然后执行 然后你应该就可以看到 可以看到flannel插件已经安装好了，由于coredns的状态和网络插件息息相关，所以flannel插件弄好后，就可以关注coredns 尤其关注coredns的状态是不是Running，如果是的话就说明你成功了 如果没成功，多半是Pending，就说明你网络插件安装的有问题，因为这个coredns和网络插件是强绑定的，只有网络插件可用，它才会从Pending转到Running 此时我们再执行 应该就能看到 结点的状态都是Ready了 6.5 编辑 kube-proxy 配置文件，mode 修改成 ipvs接下来这步我不清楚是否必要 但还是可以做下 重启 kube-proxy","date":"2025-04-19","categories":["k8s"],"tags":["k8s"]},{"title":"Github Action学习[简单使用]","url":"/2025/04/17/GithubAction学习/","content":"Github Action学习[简单使用]一、什么是Github ActionGitHub Actions 是一种持续集成和持续交付 (CI&#x2F;CD) 平台，可用于自动执行生成、测试和部署管道。 你可以创建工作流，以便在推送更改到存储库时运行测试，或将合并的拉取请求部署到生产环境。 二、尝试使用在github创建一个仓库，名为learn_cicd，同时在本地拉取仓库，并创建.github/workflows，添加github-actions-demo.yaml 然后Push上去，在github仓库的actions就可以看到已经成功了 2.1 从示例YAML文件入手，了解语法name name: GitHub Actions Demo 这个指出了工作流的名称 run-name run-name: $ is testing out GitHub Actions 🚀 这个指出了从工作流生成的工作流运行的名称，如果省略了 run-name 或仅为空格，则运行名称将设置为工作流运行的事件特定信息。 例如，对于由 push 或 pull_request 事件触发的工作流，将其设置为提交消息或拉取请求的标题。 此值可包含表达式，且可引用 github 和 inputs 上下文，这里引用的$&#123;&#123; github.actor &#125;&#125; 就是指触发初始工作流运行的用户的用户名 on on: [push] 这个是指出了触发工作流的事件，这里的push是指当推送到工作流存储库中的任何分支时，将运行具有以下 on 值的工作流 常见的写法是 ✅ 含义： 当有人 推送（push）代码到 main 分支 时，就会触发这个工作流。 比如： 你运行 git push origin main 你 merge 了一个 PR 到 main 分支 CI 会自动跑一遍 ✅ 含义： 当有人对 main 分支发起 Pull Request（PR） 时，也会触发工作流。 比如： 你新建了一个从 feature/login → main 的 PR 你更新了这个 PR 的内容（继续 push） CI 也会自动跑一遍，确保 PR 合规 jobs jobs 工作流运行由一个或多个 jobs 组成，默认情况下并行运行。 若要按顺序运行作业，可以使用 jobs.[job_id].needs 关键字定义对其他作业的依赖关系。 每个作业在 runs-on 指定的运行器环境中运行。 显然在这个jobs中只有一个job，为Explore-GitHub-Actions job.[job_id]使用 jobs.[job_id] 为作业提供唯一标识符。 键 job_id 是一个字符串，其值是作业配置数据的映射。 必须将 [job_id] 替换为对于 jobs 对象的唯一字符串。 [job_id] 必须以字母或 _ 开头，并且只能包含字母数字字符、- 或 _。 示例：创建作业 在此示例中，已创建两个作业，其 job_id 值为 my_first_job 和 my_second_job。 job.[job_id].name使用 jobs.[job_id].name 设置作业名称，该名称显示在 GitHub UI 中。 job.[job_id].needs使用 jobs.[job_id].needs 标识运行此作业之前必须成功完成的所有作业。 它可以是一个字符串，也可以是字符串数组。 如果某个作业失败或跳过，则所有需要它的作业都会被跳过，除非这些作业使用让该作业继续的条件表达式。 如果运行包含一系列相互需要的作业，则故障或跳过将从故障点或跳过点开始，应用于依赖项链中的所有作业。 如果希望某个作业在其依赖的作业未成功时也能运行，请在 jobs.[job_id].if 中使用 always() 条件表达式。 示例：要求成功的依赖项作业 在此示例中，job1 必须在 job2 开始之前成功完成，并且 job3 等待 job1 和 job2 完成。 示例：不要求成功的依赖项作业 在此示例中，job3 使用 always() 条件表达式，确保始终在 job1 和 job2 完成（无论是否成功）后运行。 有关详细信息，请参阅“对工作流和操作中的表达式求值”。 jobs.[job_id].runs-on使用 jobs.[job_id].runs-on 定义要运行作业的计算机类型 这里就贴下可以免费使用的 虚拟机 处理器 (CPU) 内存 (RAM) 存储 (SSD) 体系结构 工作流标签 Linux 4 16 GB 14 GB x64 ubuntu-latest、ubuntu-24.04、ubuntu-22.04、ubuntu-20.04 Windows 4 16 GB 14 GB x64 windows-latest、windows-2025、windows-2022、windows-2019 Linux [公共预览版] 4 16 GB 14 GB arm64 ubuntu-24.04-arm，ubuntu-22.04-arm Windows [公共预览版] 4 16 GB 14 GB arm64 windows-11-arm macOS 4 14 GB 14 GB Intel macos-13 macOS 3 (M1) 7 GB 14 GB arm64 macos-latest, macos-14, macos-15 jobs.[job_id].steps作业包含一系列任务，称为 steps。 步骤可以运行命令、运行设置任务，或者运行您的仓库、公共仓库中的操作或 Docker 注册表中发布的操作。 并非所有步骤都会运行操作，但所有操作都会作为步骤运行。 每个步骤在运行器环境中以其自己的进程运行，且可以访问工作区和文件系统。 因为步骤以自己的进程运行，所以步骤之间不会保留环境变量的更改。 GitHub 提供内置的步骤来设置和完成作业。 jobs.[job_id].steps[*].name步骤显示在 GitHub 上的名称。 jobs.[job_id].step[*].run使用操作系统的 shell 运行不超过 21,000 个字符的命令行程序。 如果不提供 name，步骤名称将默认为 run 命令中指定的文本。 每个 run 关键字代表运行器环境中一个新的进程和 shell。 当您提供多行命令时，每行都在同一个 shell 中运行。 例如： 单行命令： 多行命令： jobs.[job_id].step[*].working-directory使用 working-directory 关键字，你可以指定运行命令的工作目录位置。 jobs.[job_id].step[*].uses选择要作为作业中步骤的一部分运行的操作。 操作是一种可重复使用的代码单位。 某些操作需要必须使用 with 关键字设置的输入 简单来说，就直接使用别人打包好的操作 比如 三、小试牛刀我们来测验下，先弄下CI（持续集成），意思就是每次提交代码时，自动检测它是否能成功构建并通过测试。 我们弄个简单的demo main.go gin_test.go .github&#x2F;workflows&#x2F;ci.yaml 这里是直接套模板了 push上去后就可以看到 ok，这样一个简单的CI就完成了 感觉这个工具还是挺方便的😋","date":"2025-04-17","categories":["CI/CD"],"tags":["CI/CD"]},{"title":"如何用interface","url":"/2025/04/16/如何用interface/","content":"如何用interface一、了解下interface的相关知识1、interface是一种类型 首先 interface 是一种类型，从它的定义可以看出来用了 type 关键字，更准确的说 interface 是一种具有一组方法的类型，这些方法定义了 interface 的行为。 go 允许不带任何方法的 interface ，这种类型的 interface 叫 empty interface（空接口）。 如果一个类型实现了一个 interface 中所有方法，我们说类型实现了该 interface，所以所有类型都实现了 empty interface，因为任何一种类型至少实现了 0 个方法。go 没有显式的关键字用来实现 interface，只需要实现 interface 包含的方法即可。 上述例子中，i结构体有一个方法func (ii *i) Get()int 而接口I中只有一个方法Get() int，因为i结构体实现了接口I的所有方法，我们就称i结构体实现了接口I 2、interface 变量存储的是实现者的值 函数f的参数是接口I，而Dog结构体和i结构体都实现了接口I，所以他们都可以被传入函数f中 不难看出两次调用f，分别输出的是d和ii的age字段 在使用 interface 时不需要显式在 struct 上声明要实现哪个 interface ，只需要实现对应 interface 中的方法即可，go 会自动进行 interface 的检查，并在运行时执行从其他类型到 interface 的自动转换 大概了解这些就足够了，如果你想更加了解interface的用法，可以自行搜索 接下来，我们来聊聊接口具体要如何使用 二、接口如何正确地使用Producers and Consumers（生产者和消费者）首先，这句话适用于哪里？这一切都归结为生产者包和消费者包之间的交互。生产者提供一些服务，消费者使用它。这种交互很常见，因为我们通常将代码组织到不同职责的包中。然后，包使用者将依赖于外部包来实现某些功能。 我们将给一个简单的演示来贯穿全文 在db包中， db.go提供了一些持久存储功能。在user包中， user.go包含一些我们想要与用户处理的业务逻辑。在这里， user包将成为consumer，使用db包提供的有状态服务。 Let the consumer define the interfaces it uses（让消费者定义其使用的接口）也就是说，接口应该由consumer来定义，而不是producer 来看下面的代码 这里db.go简单提供了一些插入和读取的方法 消费者user.go需要数据存储的相关依赖才能执行与用户相关的业务逻辑，它不关心存储具体是怎么实现的，而只需要关心它具体需要什么 所以，它只关心它需要2个方法：Insert()和Get()，因此，它能够实现创建和查询用户 因此，它定义了自己的接口UserStore并接收它作为其依赖项，而db.go中的Store结构实现了该接口，所以其可作依赖项 所以说，接受接口就是让消费者在接口中定义他们想要的内容，消费者不用担心谁能实现（我们帮他实现），只需要关注这个接口可以执行消费者需要的任务即可 而这样做，也会带来一些好处： 更松散的耦合，以及更灵活 通过接受接口，消费者不会与其依赖关系耦合。如果明天我决定使用 MySQL 而不是 Postgres，则user.go根本不需要更改。只要满足消费者定义的接口，这就保留了使用任何存储的灵活性。 更容易测试 测试也会变得更简单，因为我们可以轻松地传递内存中的模拟，而不必启动实际的数据库实例，这对于单元测试来说可能会很麻烦。我们可以拥有一个模拟内存存储，其中包含测试用例所需的适当数据。 Producers return concrete types（生产者返回具体的类型）也就是说，producer应该向consumer提供具体的类型而不是接口 为什么呢？ producer不一定只为某个consumer提供服务，如果很多consumer都需要用到producer中的方法（以接口的形式），那producer就得为每个consumer都返回某个特定的接口，但这就违背了我们返回接口的目的 上面的示例中，NewDB()返回具体类型给消费者，而消费者可以隐式地将 *Store转化为UserService，其他消费者也同理，这样就可以利用这个机制，免去了为了适配各个接口的New过程 我们这里，也会给出这个Bad Case 该接口现在由生产者定义，消费者使用该接口作为入口点。这被称为抢占式接口，即生产者在实际使用接口之前抢先定义接口。 有些人可能会认为，让生产者返回一个接口，可以让开发人员专注于函数发出的 API。然而，这在 Go 中是不必要的；隐式接口允许在事后进行优雅的抽象，而不需要你预先进行抽象。 Do not define interfaces before they are used: without a realistic example of usage, it is too difficult to see whether an interface is even necessary, let alone what methods it ought to contain.（在使用接口之前不要定义它们：如果没有实际的使用示例，很难看出接口是否必要，更不用说它应该包含哪些方法了）如果没有实际的使用示例，就很难看出接口是否必要，更不用说它应该包含哪些方法了。 这里涉及到了，应该先编写接口还是先编写实例的问题 假设先编写实例，这当然可以，你可以把它可能有的方法全部列举出来，比如对于一个数据库实例，如上面的Store类型，它肯定是有CRUD这4个方法的，但是有些情况，我们却不需要U（update），那你写的方法就没用了 假设先编写接口，像上面的user那样，它清楚自己需要什么，但这对我们编写代码有什么帮助呢？很简单，借助interface，我们在写它的相关服务的时候，就很清楚如何去编写，不需要考虑谁来实现（因为我们后面肯定会实现的），这样，我们就可以很轻松地完成这个服务的逻辑（因为我们有任何我们需要的方法，没有可以自己添加嘛），后续我们只需要专注于如何实现那些接口就可以了 上面实际上是两种方向，自下而上，自上而下 自下而上固然可行，但是它缺乏了对全局的把控，因为你的高度低了，你只能把控你自己以及比你低一层级的，这会让你前期虽然写的很爽，但后期会花费大量的时间修改代码 而自上而下，拥有较为广阔的视野，因为我们，清楚自己需要哪些方法，由此，来决定下层的走向，这种编写方式，理论上可以，越写越爽，越爽越写，从此在coding的路上一去不复返😜 参考文献：https://go.dev/wiki/CodeReviewComments#interfaces https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/","date":"2025-04-16","categories":["golang"],"tags":["golang","interface"]},{"title":"关于我","url":"/about/index.html","content":"GitHub","date":"2025-04-16"},{"title":"分类","url":"/categories/index.html","content":"","date":"2025-04-16"},{"title":"标签","url":"/tags/index.html","content":"","date":"2025-04-16"},{"title":"search","url":"/search/index.html","content":"","date":"2025-04-16"},{"title":"归档","url":"/archives/index.html","content":"","date":"2025-04-16"}]