# å¦‚ä½•ç”¨interface

## ä¸€ã€äº†è§£ä¸‹interfaceçš„ç›¸å…³çŸ¥è¯†

### 1ã€interfaceæ˜¯ä¸€ç§ç±»åž‹

```go
type I interface {
    Get() int
}
```

é¦–å…ˆ **interface æ˜¯ä¸€ç§ç±»åž‹**ï¼Œä»Žå®ƒçš„å®šä¹‰å¯ä»¥çœ‹å‡ºæ¥ç”¨äº† type å…³é”®å­—ï¼Œæ›´å‡†ç¡®çš„è¯´ interface æ˜¯ä¸€ç§**å…·æœ‰ä¸€ç»„æ–¹æ³•çš„ç±»åž‹**ï¼Œè¿™äº›æ–¹æ³•å®šä¹‰äº† interface çš„è¡Œä¸ºã€‚

go å…è®¸ä¸å¸¦ä»»ä½•æ–¹æ³•çš„ interface ï¼Œè¿™ç§ç±»åž‹çš„ interface å« **empty interface**ï¼ˆç©ºæŽ¥å£ï¼‰ã€‚

**å¦‚æžœä¸€ä¸ªç±»åž‹å®žçŽ°äº†ä¸€ä¸ª interface ä¸­æ‰€æœ‰æ–¹æ³•ï¼Œæˆ‘ä»¬è¯´ç±»åž‹å®žçŽ°äº†è¯¥ interface**ï¼Œæ‰€ä»¥æ‰€æœ‰ç±»åž‹éƒ½å®žçŽ°äº† empty interfaceï¼Œå› ä¸ºä»»ä½•ä¸€ç§ç±»åž‹è‡³å°‘å®žçŽ°äº† 0 ä¸ªæ–¹æ³•ã€‚go æ²¡æœ‰æ˜¾å¼çš„å…³é”®å­—ç”¨æ¥å®žçŽ° interfaceï¼Œåªéœ€è¦å®žçŽ° interface åŒ…å«çš„æ–¹æ³•å³å¯ã€‚

```go
type I interface {
    Get() int
}
type i struct{
    age int
}
func (ii *i) Get()int {
    return ii.age
}
```

ä¸Šè¿°ä¾‹å­ä¸­ï¼Œ`i`ç»“æž„ä½“æœ‰ä¸€ä¸ªæ–¹æ³•`func (ii *i) Get()int`

è€ŒæŽ¥å£`I`ä¸­åªæœ‰ä¸€ä¸ªæ–¹æ³•`Get() int`ï¼Œå› ä¸º`i`ç»“æž„ä½“å®žçŽ°äº†æŽ¥å£`I`çš„æ‰€æœ‰æ–¹æ³•ï¼Œæˆ‘ä»¬å°±ç§°`i`ç»“æž„ä½“å®žçŽ°äº†æŽ¥å£`I`

### 2ã€interface å˜é‡å­˜å‚¨çš„æ˜¯å®žçŽ°è€…çš„å€¼

```go
type I interface {    
    Get() int
    Set(int)
}

type Dog struct {
    age int
}

func(d *Dog) Get()int {
    return d.age
}

type i struct{
    age int
}
func (ii *i) Get()int {
    return ii.age
}

func f(i I){
    fmt.Println(i.Get())
}

func main() {
    d := Dog{
        age : 1,
    } 
    ii := i{
        age : 10,
    }
    f(&d)  //1
    f(&ii) //10
}
```

å‡½æ•°fçš„å‚æ•°æ˜¯æŽ¥å£`I`ï¼Œè€ŒDogç»“æž„ä½“å’Œiç»“æž„ä½“éƒ½å®žçŽ°äº†æŽ¥å£Iï¼Œæ‰€ä»¥ä»–ä»¬éƒ½å¯ä»¥è¢«ä¼ å…¥å‡½æ•°fä¸­

ä¸éš¾çœ‹å‡ºä¸¤æ¬¡è°ƒç”¨fï¼Œåˆ†åˆ«è¾“å‡ºçš„æ˜¯då’Œiiçš„ageå­—æ®µ

åœ¨ä½¿ç”¨ interface æ—¶ä¸éœ€è¦æ˜¾å¼åœ¨ struct ä¸Šå£°æ˜Žè¦å®žçŽ°å“ªä¸ª interface ï¼Œåªéœ€è¦å®žçŽ°å¯¹åº” interface ä¸­çš„æ–¹æ³•å³å¯ï¼Œgo ä¼šè‡ªåŠ¨è¿›è¡Œ interface çš„æ£€æŸ¥ï¼Œå¹¶åœ¨è¿è¡Œæ—¶æ‰§è¡Œä»Žå…¶ä»–ç±»åž‹åˆ° interface çš„è‡ªåŠ¨è½¬æ¢



---

å¤§æ¦‚äº†è§£è¿™äº›å°±è¶³å¤Ÿäº†ï¼Œå¦‚æžœä½ æƒ³æ›´åŠ äº†è§£interfaceçš„ç”¨æ³•ï¼Œå¯ä»¥è‡ªè¡Œæœç´¢

æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¥èŠèŠæŽ¥å£å…·ä½“è¦å¦‚ä½•ä½¿ç”¨

---

## äºŒã€æŽ¥å£å¦‚ä½•æ­£ç¡®åœ°ä½¿ç”¨

### *Producers and Consumers*ï¼ˆç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…ï¼‰

é¦–å…ˆï¼Œè¿™å¥è¯é€‚ç”¨äºŽå“ªé‡Œï¼Ÿè¿™ä¸€åˆ‡éƒ½å½’ç»“ä¸º**ç”Ÿäº§è€…**åŒ…å’Œ**æ¶ˆè´¹è€…**åŒ…ä¹‹é—´çš„äº¤äº’ã€‚ç”Ÿäº§è€…æä¾›ä¸€äº›æœåŠ¡ï¼Œæ¶ˆè´¹è€…ä½¿ç”¨å®ƒã€‚è¿™ç§äº¤äº’å¾ˆå¸¸è§ï¼Œå› ä¸ºæˆ‘ä»¬é€šå¸¸å°†ä»£ç ç»„ç»‡åˆ°ä¸åŒèŒè´£çš„åŒ…ä¸­ã€‚ç„¶åŽï¼ŒåŒ…ä½¿ç”¨è€…å°†ä¾èµ–äºŽå¤–éƒ¨åŒ…æ¥å®žçŽ°æŸäº›åŠŸèƒ½ã€‚

æˆ‘ä»¬å°†ç»™ä¸€ä¸ªç®€å•çš„æ¼”ç¤ºæ¥è´¯ç©¿å…¨æ–‡

```
â”œâ”€â”€ db
â”‚   â””â”€â”€ db.go
â””â”€â”€ user
    â””â”€â”€ user.go
```

åœ¨`db`åŒ…ä¸­ï¼Œ `db.go`æä¾›äº†ä¸€äº›æŒä¹…å­˜å‚¨åŠŸèƒ½ã€‚åœ¨`user`åŒ…ä¸­ï¼Œ `user.go`åŒ…å«ä¸€äº›æˆ‘ä»¬æƒ³è¦ä¸Žç”¨æˆ·å¤„ç†çš„ä¸šåŠ¡é€»è¾‘ã€‚åœ¨è¿™é‡Œï¼Œ `user`åŒ…å°†æˆä¸ºconsumerï¼Œä½¿ç”¨`db`åŒ…æä¾›çš„æœ‰çŠ¶æ€æœåŠ¡ã€‚

### *Let the consumer define the interfaces it uses*ï¼ˆè®©æ¶ˆè´¹è€…å®šä¹‰å…¶ä½¿ç”¨çš„æŽ¥å£ï¼‰

ä¹Ÿå°±æ˜¯è¯´ï¼ŒæŽ¥å£åº”è¯¥ç”±***consumer***æ¥å®šä¹‰ï¼Œè€Œä¸æ˜¯***producer***

æ¥çœ‹ä¸‹é¢çš„ä»£ç 

```go
//db.go
package db
type Store struct {
   db *sql.DB
}
func NewDB() *Store { ... } //func to initialise DB
func (s *Store) Insert(item interface{}) error { ... } //insert item
func (s *Store) Get(id int) error { ... } //get item by id
```

è¿™é‡Œ`db.go`ç®€å•æä¾›äº†ä¸€äº›æ’å…¥å’Œè¯»å–çš„æ–¹æ³•

```go
//user.go
package user
type UserStore interface {
   Insert(item interface{}) error
   Get(id int) error
}
type UserService struct {
   store UserStore
}
// Accepting interface here!
func NewUserService(s UserStore) *UserService {
   return &UserService{
      store: s,
   }
}
func (u *UserService) CreateUser() { ... }
func (u *UserService) RetrieveUser(id int) User { ... }
```

æ¶ˆè´¹è€…`user.go`éœ€è¦æ•°æ®å­˜å‚¨çš„ç›¸å…³ä¾èµ–æ‰èƒ½æ‰§è¡Œä¸Žç”¨æˆ·ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘ï¼Œå®ƒä¸å…³å¿ƒå­˜å‚¨å…·ä½“æ˜¯æ€Žä¹ˆå®žçŽ°çš„ï¼Œè€Œåªéœ€è¦***å…³å¿ƒå®ƒå…·ä½“éœ€è¦ä»€ä¹ˆ***

æ‰€ä»¥ï¼Œå®ƒåªå…³å¿ƒå®ƒéœ€è¦2ä¸ªæ–¹æ³•ï¼š`Insert()`å’Œ`Get()`ï¼Œå› æ­¤ï¼Œå®ƒèƒ½å¤Ÿå®žçŽ°åˆ›å»ºå’ŒæŸ¥è¯¢ç”¨æˆ·

å› æ­¤ï¼Œå®ƒå®šä¹‰äº†è‡ªå·±çš„æŽ¥å£`UserStore`å¹¶æŽ¥æ”¶å®ƒä½œä¸ºå…¶ä¾èµ–é¡¹ï¼Œè€Œ`db.go`ä¸­çš„`Store`ç»“æž„å®žçŽ°äº†è¯¥æŽ¥å£ï¼Œæ‰€ä»¥å…¶å¯ä½œä¾èµ–é¡¹

æ‰€ä»¥è¯´ï¼ŒæŽ¥å—æŽ¥å£å°±æ˜¯è®©æ¶ˆè´¹è€…åœ¨æŽ¥å£ä¸­å®šä¹‰ä»–ä»¬æƒ³è¦çš„å†…å®¹ï¼Œæ¶ˆè´¹è€…ä¸ç”¨æ‹…å¿ƒè°èƒ½å®žçŽ°ï¼ˆæˆ‘ä»¬å¸®ä»–å®žçŽ°ï¼‰ï¼Œåªéœ€è¦å…³æ³¨è¿™ä¸ªæŽ¥å£å¯ä»¥æ‰§è¡Œæ¶ˆè´¹è€…éœ€è¦çš„ä»»åŠ¡å³å¯

è€Œè¿™æ ·åšï¼Œä¹Ÿä¼šå¸¦æ¥ä¸€äº›å¥½å¤„ï¼š

+ æ›´æ¾æ•£çš„è€¦åˆï¼Œä»¥åŠæ›´çµæ´»

é€šè¿‡æŽ¥å—æŽ¥å£ï¼Œæ¶ˆè´¹è€…ä¸ä¼šä¸Žå…¶ä¾èµ–å…³ç³»è€¦åˆã€‚å¦‚æžœæ˜Žå¤©æˆ‘å†³å®šä½¿ç”¨ MySQL è€Œä¸æ˜¯ Postgresï¼Œåˆ™`user.go`æ ¹æœ¬ä¸éœ€è¦æ›´æ”¹ã€‚åªè¦æ»¡è¶³æ¶ˆè´¹è€…å®šä¹‰çš„æŽ¥å£ï¼Œè¿™å°±ä¿ç•™äº†ä½¿ç”¨ä»»ä½•å­˜å‚¨çš„çµæ´»æ€§ã€‚

+ æ›´å®¹æ˜“æµ‹è¯•
+ æµ‹è¯•ä¹Ÿä¼šå˜å¾—æ›´ç®€å•ï¼Œå› ä¸ºæˆ‘ä»¬å¯ä»¥è½»æ¾åœ°ä¼ é€’å†…å­˜ä¸­çš„æ¨¡æ‹Ÿï¼Œè€Œä¸å¿…å¯åŠ¨å®žé™…çš„æ•°æ®åº“å®žä¾‹ï¼Œè¿™å¯¹äºŽå•å…ƒæµ‹è¯•æ¥è¯´å¯èƒ½ä¼šå¾ˆéº»çƒ¦ã€‚æˆ‘ä»¬å¯ä»¥æ‹¥æœ‰ä¸€ä¸ªæ¨¡æ‹Ÿå†…å­˜å­˜å‚¨ï¼Œå…¶ä¸­åŒ…å«æµ‹è¯•ç”¨ä¾‹æ‰€éœ€çš„é€‚å½“æ•°æ®ã€‚

```go
type inMemStore struct {
    mp map[string]interface{}
}

//user_test.gofunc TestCreateUser(t *testing.T) {
   s := new(inMemStore) //use some in-memory store...
   service := NewUserService(s)
   
   //... test the CreateUser() function
}
```

### *Producers return concrete types*ï¼ˆç”Ÿäº§è€…è¿”å›žå…·ä½“çš„ç±»åž‹ï¼‰

ä¹Ÿå°±æ˜¯è¯´ï¼Œ***producer***åº”è¯¥å‘***consumer***æä¾›å…·ä½“çš„ç±»åž‹è€Œä¸æ˜¯æŽ¥å£

ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

***producer***ä¸ä¸€å®šåªä¸ºæŸä¸ª***consumer***æä¾›æœåŠ¡ï¼Œå¦‚æžœå¾ˆå¤š***consumer***éƒ½éœ€è¦ç”¨åˆ°***producer***ä¸­çš„æ–¹æ³•ï¼ˆä»¥æŽ¥å£çš„å½¢å¼ï¼‰ï¼Œé‚£***producer***å°±å¾—ä¸ºæ¯ä¸ª***consumer***éƒ½è¿”å›žæŸä¸ªç‰¹å®šçš„æŽ¥å£ï¼Œä½†è¿™å°±è¿èƒŒäº†æˆ‘ä»¬è¿”å›žæŽ¥å£çš„ç›®çš„

ä¸Šé¢çš„ç¤ºä¾‹ä¸­ï¼Œ`NewDB()`è¿”å›žå…·ä½“ç±»åž‹ç»™æ¶ˆè´¹è€…ï¼Œè€Œæ¶ˆè´¹è€…å¯ä»¥éšå¼åœ°å°†

`*Store`è½¬åŒ–ä¸º`UserService`ï¼Œå…¶ä»–æ¶ˆè´¹è€…ä¹ŸåŒç†ï¼Œè¿™æ ·å°±å¯ä»¥åˆ©ç”¨è¿™ä¸ªæœºåˆ¶ï¼Œå…åŽ»äº†ä¸ºäº†é€‚é…å„ä¸ªæŽ¥å£çš„Newè¿‡ç¨‹

æˆ‘ä»¬è¿™é‡Œï¼Œä¹Ÿä¼šç»™å‡ºè¿™ä¸ª`Bad Case`

```go
//postgres.go
package db

type Store interface {
   Insert(item interface{}) error
   Get(id int) error
}

type MyStore struct {
   db *sql.DB
}

func InitDB() Store { ... } //func to initialise DB
func (s *Store) Insert(item interface{}) error { ... } //insert item
func (s *Store) Get(id int) error { ... } //get item by id



//user.go
package user

type UserService struct {
   store db.Store
}

func NewUserService(s db.Store) *UserService {
   return &UserService{
      store: s,
   }
}
func (u *UserService) CreateUser() { ... }
func (u *UserService) RetrieveUser(id int) User { ... }
```

è¯¥æŽ¥å£çŽ°åœ¨ç”±ç”Ÿäº§è€…å®šä¹‰ï¼Œæ¶ˆè´¹è€…ä½¿ç”¨è¯¥æŽ¥å£ä½œä¸ºå…¥å£ç‚¹ã€‚è¿™è¢«ç§°ä¸º*æŠ¢å å¼æŽ¥å£*ï¼Œå³ç”Ÿäº§è€…åœ¨å®žé™…ä½¿ç”¨æŽ¥å£ä¹‹å‰æŠ¢å…ˆå®šä¹‰æŽ¥å£ã€‚

æœ‰äº›äººå¯èƒ½ä¼šè®¤ä¸ºï¼Œè®©ç”Ÿäº§è€…è¿”å›žä¸€ä¸ªæŽ¥å£ï¼Œå¯ä»¥è®©å¼€å‘äººå‘˜ä¸“æ³¨äºŽå‡½æ•°å‘å‡ºçš„ APIã€‚ç„¶è€Œï¼Œè¿™åœ¨ Go ä¸­æ˜¯ä¸å¿…è¦çš„ï¼›éšå¼æŽ¥å£å…è®¸åœ¨äº‹åŽè¿›è¡Œä¼˜é›…çš„æŠ½è±¡ï¼Œè€Œä¸éœ€è¦ä½ é¢„å…ˆè¿›è¡ŒæŠ½è±¡ã€‚

### Do not define interfaces before they are used: without a realistic example of usage, it is too difficult to see whether an interface is even necessary, let alone what methods it ought to contain.ï¼ˆåœ¨ä½¿ç”¨æŽ¥å£ä¹‹å‰ä¸è¦å®šä¹‰å®ƒä»¬ï¼šå¦‚æžœæ²¡æœ‰å®žé™…çš„ä½¿ç”¨ç¤ºä¾‹ï¼Œå¾ˆéš¾çœ‹å‡ºæŽ¥å£æ˜¯å¦å¿…è¦ï¼Œæ›´ä¸ç”¨è¯´å®ƒåº”è¯¥åŒ…å«å“ªäº›æ–¹æ³•äº†ï¼‰

å¦‚æžœæ²¡æœ‰å®žé™…çš„ä½¿ç”¨ç¤ºä¾‹ï¼Œå°±å¾ˆéš¾çœ‹å‡ºæŽ¥å£æ˜¯å¦å¿…è¦ï¼Œæ›´ä¸ç”¨è¯´å®ƒåº”è¯¥åŒ…å«å“ªäº›æ–¹æ³•äº†ã€‚

è¿™é‡Œæ¶‰åŠåˆ°äº†ï¼Œåº”è¯¥å…ˆç¼–å†™æŽ¥å£è¿˜æ˜¯å…ˆç¼–å†™å®žä¾‹çš„é—®é¢˜

+ å‡è®¾å…ˆç¼–å†™å®žä¾‹ï¼Œè¿™å½“ç„¶å¯ä»¥ï¼Œä½ å¯ä»¥æŠŠå®ƒå¯èƒ½æœ‰çš„æ–¹æ³•å…¨éƒ¨åˆ—ä¸¾å‡ºæ¥ï¼Œæ¯”å¦‚å¯¹äºŽä¸€ä¸ªæ•°æ®åº“å®žä¾‹ï¼Œå¦‚ä¸Šé¢çš„***Store***ç±»åž‹ï¼Œå®ƒè‚¯å®šæ˜¯æœ‰CRUDè¿™4ä¸ªæ–¹æ³•çš„ï¼Œä½†æ˜¯æœ‰äº›æƒ…å†µï¼Œæˆ‘ä»¬å´ä¸éœ€è¦Uï¼ˆupdateï¼‰ï¼Œé‚£ä½ å†™çš„æ–¹æ³•å°±æ²¡ç”¨äº†
+ å‡è®¾å…ˆç¼–å†™æŽ¥å£ï¼Œåƒä¸Šé¢çš„***user***é‚£æ ·ï¼Œå®ƒæ¸…æ¥šè‡ªå·±éœ€è¦ä»€ä¹ˆï¼Œä½†è¿™å¯¹æˆ‘ä»¬ç¼–å†™ä»£ç æœ‰ä»€ä¹ˆå¸®åŠ©å‘¢ï¼Ÿå¾ˆç®€å•ï¼Œå€ŸåŠ©***interface***ï¼Œæˆ‘ä»¬åœ¨å†™å®ƒçš„ç›¸å…³æœåŠ¡çš„æ—¶å€™ï¼Œå°±å¾ˆæ¸…æ¥šå¦‚ä½•åŽ»ç¼–å†™ï¼Œä¸éœ€è¦è€ƒè™‘è°æ¥å®žçŽ°ï¼ˆå› ä¸ºæˆ‘ä»¬åŽé¢è‚¯å®šä¼šå®žçŽ°çš„ï¼‰ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥å¾ˆè½»æ¾åœ°å®Œæˆè¿™ä¸ªæœåŠ¡çš„é€»è¾‘ï¼ˆå› ä¸ºæˆ‘ä»¬æœ‰ä»»ä½•æˆ‘ä»¬éœ€è¦çš„æ–¹æ³•ï¼Œæ²¡æœ‰å¯ä»¥è‡ªå·±æ·»åŠ å˜›ï¼‰ï¼ŒåŽç»­æˆ‘ä»¬åªéœ€è¦ä¸“æ³¨äºŽå¦‚ä½•å®žçŽ°é‚£äº›æŽ¥å£å°±å¯ä»¥äº†

ä¸Šé¢å®žé™…ä¸Šæ˜¯ä¸¤ç§æ–¹å‘ï¼Œ***è‡ªä¸‹è€Œä¸Š***ï¼Œ***è‡ªä¸Šè€Œä¸‹***

è‡ªä¸‹è€Œä¸Šå›ºç„¶å¯è¡Œï¼Œä½†æ˜¯å®ƒç¼ºä¹äº†å¯¹å…¨å±€çš„æŠŠæŽ§ï¼Œå› ä¸ºä½ çš„é«˜åº¦ä½Žäº†ï¼Œä½ åªèƒ½æŠŠæŽ§ä½ è‡ªå·±ä»¥åŠæ¯”ä½ ä½Žä¸€å±‚çº§çš„ï¼Œè¿™ä¼šè®©ä½ å‰æœŸè™½ç„¶å†™çš„å¾ˆçˆ½ï¼Œä½†åŽæœŸä¼šèŠ±è´¹å¤§é‡çš„æ—¶é—´ä¿®æ”¹ä»£ç 

è€Œè‡ªä¸Šè€Œä¸‹ï¼Œæ‹¥æœ‰è¾ƒä¸ºå¹¿é˜”çš„è§†é‡Žï¼Œå› ä¸ºæˆ‘ä»¬ï¼Œæ¸…æ¥šè‡ªå·±éœ€è¦å“ªäº›æ–¹æ³•ï¼Œç”±æ­¤ï¼Œæ¥å†³å®šä¸‹å±‚çš„èµ°å‘ï¼Œè¿™ç§ç¼–å†™æ–¹å¼ï¼Œç†è®ºä¸Šå¯ä»¥ï¼Œè¶Šå†™è¶Šçˆ½ï¼Œè¶Šçˆ½è¶Šå†™ï¼Œä»Žæ­¤åœ¨codingçš„è·¯ä¸Šä¸€åŽ»ä¸å¤è¿”ðŸ˜œ



> å‚è€ƒæ–‡çŒ®ï¼šhttps://go.dev/wiki/CodeReviewComments#interfaces
>
> https://sanyuesha.com/2017/07/22/how-to-understand-go-interface/